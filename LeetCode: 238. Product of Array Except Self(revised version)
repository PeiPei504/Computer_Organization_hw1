    .globl productExceptSelf
.text
productExceptSelf:
    addi sp, sp, -16               # Adjust stack pointer to allocate space for saving registers
    sw ra, 12(sp)                  # Save return address
    sw s0, 8(sp)                   # Save register s0
    sw s1, 4(sp)                   # Save register s1
    sw s2, 0(sp)                   # Save register s2

    add s0, a0, x0                 # s0 = address of nums[]
    add s1, a1, x0                 # s1 = numsSize
    add s2, a2, x0                 # s2 = address of answer[]

    addi t0, x0, 1                 # t0 = left running product, initialize to 1
    addi t3, x0, 0                 # t3 = index (initialize to 0)

    # Calculate left product
left_product_loop:
    bge t3, s1, right_product_init # If t3 >= numsSize, exit the loop
    
    # Calculate answer[t3]
    slli t4, t3, 2                 # t4 = t3 * 4 (calculate current index offset)
    add t5, s2, t4                 # t5 = &answer[t3]
    sw t0, 0(t5)                   # answer[t3] = left running product

    # Update left running product
    add t6, s0, t4                 # t6 = &nums[t3]
    lw t4, 0(t6)                   # t4 = nums[t3]
    add t0, t0, t5                 # Accumulate product into t0

    addi t3, t3, 1                 # t3++
    j left_product_loop            # Continue calculating left product

right_product_init:
    addi t1, x0, 1                 # Initialize t1 to 1 (right running product)
    addi t3, s1, -1                # t3 = numsSize - 1

    # Calculate right product
right_product_loop:
    blt t3, x0, end_function       # If t3 < 0, exit the loop

    # Calculate answer[t3] = answer[t3] * right
    slli t4, t3, 2                 # t4 = t3 * 4 (calculate current index offset)
    add t5, s2, t4                 # t5 = &answer[t3]
    lw t6, 0(t5)                   # t6 = answer[t3]
    add t6, t6, t1                 # Simulate multiplication, add right to t6
    sw t6, 0(t5)                   # Update answer[t3]

    # Update right as right * nums[t3]
    add t6, s0, t4                 # t6 = &nums[t3]
    lw t5, 0(t6)                   # t5 = nums[t3]
    add t1, t1, t5                 # Simulate multiplication, add nums[t3] to right

    addi t3, t3, -1                # t3--
    j right_product_loop           # Continue calculating right product

end_function:
    lw ra, 12(sp)                  # Restore return address
    lw s0, 8(sp)                   # Restore register s0
    lw s1, 4(sp)                   # Restore register s1
    lw s2, 0(sp)                   # Restore register s2
    addi sp, sp, 16                # Restore stack pointer
                         
# Program exit
    li a7, 10
    ecall
