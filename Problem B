.data
argument: .word   0x3E800000   # float 0.25 (32-bit IEEE 754)

.text

_start:
    j main

fp32_to_bf16:
    la a0, argument        # Load the address of the argument
    lw a1, 0(a0)           # Load float 0.25 (32-bit IEEE 754) from memory

    # NaN Check
    li a2, 0x7F800000      # NaN threshold
    li a3, 0x7FFFFFFF      # Mask to remove the sign bit
    and a4, a1, a3         # u.i & 0x7FFFFFFF
    bgtu a4, a2, non_case  # If u.i > 0x7F800000, handle NaN case

    # Rounding and conversion to bfloat16
    li a2, 0x7FFF          # Constant 0x7FFF
    srli a3, a1, 16        # Shift right to extract the top 16 bits of u.i
    li t0, 0x8000          # Load the 0x8000 value for rounding
    and a3, a1, t0         # Check the 17th bit for rounding (u.i >> 15) & 1
    add a3, a3, a2         # 0x7FFF + (u.i >> 15) & 1 (Rounding)
    add a3, a3, a1         # u.i + (0x7FFF + (u.i >> 15) & 1)
    srli a0, a3, 16        # Shift right to get the final bfloat16 value
    ret                    # Return the result in a0

non_case:
    # Handle NaN case
    srli a1, a1, 16        # Shift right by 16 bits
    li a4, 0x0040          # Set the quiet NaN flag
    or a0, a1, a4          # Set the final result as (u.i >> 16) | 0x40
    ret

print_result:
    li a7, 1               # syscall number for print integer (assuming RISC-V Linux)
    ecall                  # make system call to print the value in a0
    ret

main:
    jal ra, fp32_to_bf16    # Call the fp32_to_bf16 function
    jal ra, print_result    # Print the result stored in a0

end:
    nop
